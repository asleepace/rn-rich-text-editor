export type ParseElement = {
  item: string
  kind: 'value' | 'start' | 'close'
}

// regex will match everything between < and >, including the brackets
const regex = /<([^>]*)>/g;

const BODY_START = "body"
const BODY_CLOSE = "/body"

function toStyle(opening: string) {
  return opening.replace(" class=\"", ".").replace("\"","")
}

function checkIfElementIsBracket(index: number, body: string[]) {
  if (index < 0 || index >= body.length) return false
  return body[index] === "" || body[index] === "\n"
}

/**
 * This method takes a string of HTML generated by Cocoa (iOS) and parses it into an array of elements,
 * which can then be reconstructed with the buildPadletHtml function.
 */
export function parseCocoaHtml(htmlString: string) {

  // split the string into an array of strings and tags
  const splits: string[] = htmlString.split(regex)

  // find the starting and closing index of the body
  const bodyStartIndex = splits.indexOf(BODY_START)
  const bodyCloseIndex = splits.indexOf(BODY_CLOSE)

  // extract only the body html elements (start + 1)
  const body = splits.slice(bodyStartIndex + 1, bodyCloseIndex)

  // convert elements into parsed syntax
  return body.reduce((tree, item, index) => {

    if (item === "") return tree  // skip if empty element

    // check if the next or previous element is a bracket
    const isPrevElementBracket = checkIfElementIsBracket(index - 1, body)
    const isNextElementBracket = checkIfElementIsBracket(index + 1, body)

    if (isPrevElementBracket) {
      tree.push({ item: toStyle(item), kind: 'start' })

    } else if (isNextElementBracket) {
      tree.push({ item, kind: 'close' })

    } else {
      tree.push({ item, kind: 'value' })
    }

    return tree

  }, [] as ParseElement[])
}
